# Kubernetes ConfigMaps and Secrets

- https://kubernetes.io/docs/concepts/configuration/configmap/#using-configmaps-as-environment-variables
- https://kubernetes.io/docs/concepts/configuration/secret/#basic-authentication-secret
- https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#define-container-environment-variables-using-secret-data

In Kubernetes, **ConfigMaps** and **Secrets** are used to manage configuration data and sensitive information separately from the application code. This helps achieve clean separation of concerns and promotes secure, manageable deployments.

---

## 1. ConfigMap

**ConfigMaps** allow you to decouple configuration artifacts from image content to keep containerized applications portable.

### Use Cases:

* Storing non-sensitive configuration data such as URLs, port numbers, file paths, environment-specific variables.

### Creating a ConfigMap

#### a. From a file:

```bash
kubectl create configmap mongo-config --from-file=config.properties
```

##### Explanation:

This command creates a ConfigMap named `mongo-config` by reading key-value pairs from the file `config.properties`.

**create a file named `config.properties` and place the below content**:
```
db_hostname: mongo
```

This is helpful when you prefer to maintain configurations in external files instead of writing them directly in YAML.

#### b. From literal values:

```bash
## Store Mongo DB host in a ConfigMap
kubectl create configmap mongo-config \
  --from-literal=db_hostname=mongo

## we can also store multiple values in single ConfigMap
kubectl create configmap new-config \
  --from-literal=APP_ENV=production \
  --from-literal=APP_PORT=8080
```

**Resulting ConfigMap Data:**

```yaml
$ kubectl describe configmap mongo-config
Name:         mongo-config
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
db_hostname:
----
mongo
```

```yaml
$ kubectl describe configmap new-config
Name:         new-config
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
APP_ENV:
----
production

APP_PORT:
----
8080
```

#### c. YAML Example:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongo-config
data:
  db_hostname: mongo
```

### Using ConfigMap in a Pod:

```yaml
env:
  - name: MONGO_DB_HOSTNAME
    valueFrom:
      configMapKeyRef:
        name: mongo-config
        key: db_hostname
```

---

## 2. Secret

**Secrets** are intended to hold sensitive information such as passwords, tokens, or SSH keys.

### Use Cases:

* Storing DB credentials, API keys, tokens, etc.

### Creating a Secret

#### a. From literal values:

```bash
## Store MongoDB credentials in a Secret:
kubectl create secret generic mongo-secret \
  --from-literal=username=admin \
  --from-literal=password=secret123
```

#### b. YAML Example:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mongo-secret
type: Opaque
data:
  username: YWRtaW4=            # base64 encoded 'admin'
  password: c2VjcmV0MTIz        # base64 encoded 'secret123'
```

### You can encode the values to Base64 using the command:
```bash
echo -n 'admin' | base64
echo -n 'secret123' | base64
```

### Similarly we can decode the values using the command:
```bash
echo 'YWRtaW4=' | base64 --decode
echo 'c2VjcmV0MTIz' | base64 --decode
```

### Using Secret in a Pod:

```yaml
env:
  - name: MONGO_DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: mongo-secret
        key: username
  - name: MONGO_DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mongo-secret
        key: password
```

### ⚠️ Important Note on Security:

Kubernetes Secrets are base64-encoded, **not encrypted by default**. This means:

* Anyone with read access to the secret (via `kubectl get secret -o yaml`) can **view and decode** the credentials easily.

```bash
echo 'c2VjcmV0MTIz' | base64 --decode    # Output: secret123
```

* It's essential to use **RBAC** (Role-Based Access Control) to limit who can access secrets.
* Enable **encryption at rest** for secrets in Kubernetes to improve security.

---

## 3. Best Practices

* Avoid hardcoding sensitive data in Deployment YAMLs.
* Mount secrets and config maps as environment variables or volumes.
* Use RBAC policies to restrict access to secrets.
* Consider enabling encryption at rest for secrets.

---
---
---

# Conclusion: Next Steps for Your Project
You can:

* Store DB host in a ConfigMap:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mongo-config
data:
  db_hostname: mongo
```

* Store MongoDB credentials in a Secret:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mongo-secret
type: Opaque
data:
  username: YWRtaW4=            # admin
  password: c2VjcmV0MTIz        # secret123
```

* Update user-management Deployment:

```yaml
env:
  - name: MONGO_DB_HOSTNAME
    valueFrom:
      configMapKeyRef:
        name: mongo-config
        key: db_hostname
  - name: MONGO_DB_USERNAME
    valueFrom:
      secretKeyRef:
        name: mongo-secret
        key: username
  - name: MONGO_DB_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mongo-secret
        key: password
```

This helps keep credentials secure and configuration manageable.

---
---
---
# Real-World Credential Management in Kubernetes

In real-world production environments, managing database credentials securely is critical. Enterprises avoid hardcoding static credentials in pods or application code. Instead, they use various strategies like Kubernetes Secrets, external secret managers (e.g., AWS Secrets Manager, HashiCorp Vault), or IAM-based authentication to secure sensitive information.

---

## 1. Kubernetes Secrets

Kubernetes Secrets are commonly used to store sensitive data like database passwords, API keys, or SSH credentials.

### Advantages

* Centralized management within Kubernetes
* Controlled access with Kubernetes RBAC
* Supports encryption at rest (with encryption provider)

### Example:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
  namespace: default
type: Opaque
data:
  username: YWRtaW4=  # base64 for "admin"
  password: c2VjcmV0MTIz  # base64 for "secret123"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  template:
    spec:
      containers:
      - name: app-container
        env:
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: password
```

---

## 2. External Secret Managers

Tools like **AWS Secrets Manager**, **HashiCorp Vault**, or **Azure Key Vault** provide centralized secret management, access control, auditing, and automatic rotation.

### Benefits:

* Dynamic and short-lived secrets
* IAM or policy-based access control
* Multi-cluster secret sharing
* Audit logging for compliance

### Integration Example:

Use the **External Secrets Operator** for Kubernetes:
[https://external-secrets.io](https://external-secrets.io)

Or Vault Agent Injector with HashiCorp Vault:
[https://developer.hashicorp.com/vault/docs/kubernetes](https://developer.hashicorp.com/vault/docs/kubernetes)

---

## 3. IAM-based Authentication (AWS RDS)

One robust and secure approach for RDS (MySQL/PostgreSQL) is to use **IAM-based authentication**. Instead of hardcoded credentials, the application fetches temporary tokens using an IAM role associated with its service account.

### Benefits:

* No static secrets in the pod
* Short-lived, auto-expiring tokens
* Full audit via CloudTrail
* Integrated with EKS using IRSA (IAM Roles for Service Accounts)

### How it Works:

1. Enable IAM authentication on the RDS instance.
2. Create an IAM policy with `rds-db:connect`.
3. Attach this policy to a role trusted by EKS OIDC.
4. Annotate the Kubernetes service account with this IAM role.
5. Use AWS CLI or SDK to fetch the token at runtime.

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: rds-access-sa
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::<account-id>:role/RDSAccessRole
```

### Application Example:

```bash
mysql -h <rds-endpoint> \
  -u iam_user \
  -p$(aws rds generate-db-auth-token --hostname <rds-endpoint> --port 3306 --username iam_user --region <region>) \
  --ssl
```

---

## 4. Comparison Table

| Feature             | Kubernetes Secrets | External Secret Manager | IAM Auth (RDS) |
| ------------------- | ------------------ | ----------------------- | -------------- |
| Static Credentials  | Yes                | Optional                | No             |
| Rotation Required   | Manual             | Optional/Auto           | Automatic      |
| IAM Integration     | No                 | Yes                     | Yes            |
| CloudTrail Auditing | Limited            | Yes                     | Yes            |
| Complexity          | Low                | Medium                  | Medium/High    |

---

## 5. Best Practices

* Always enable encryption at rest for secrets.
* Use IRSA to avoid passing AWS keys into pods.
* Rotate static credentials periodically.
* Prefer IAM authentication or dynamic secrets for high-security workloads.
* Use least privilege for IAM policies and Kubernetes RBAC.

---

## Conclusion

Credential management is a critical aspect of secure Kubernetes deployments. Based on your organization's maturity and infrastructure, you can choose from:

* Native Kubernetes Secrets (good for simple use cases)
* External Secret Managers (good for cross-cloud, multi-cluster setups)
* IAM-based Authentication (ideal for AWS-native environments)

These practices reduce the risk of leaked credentials and improve the security posture of your cloud-native applications.

---

### References:

* [https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html)
* [https://developer.hashicorp.com/vault](https://developer.hashicorp.com/vault)
* [https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html)
* [https://external-secrets.io](https://external-secrets.io)
* https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html
* https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.Connecting.html
* https://aws.amazon.com/blogs/database/using-iam-authentication-to-connect-with-pgadmin-amazon-aurora-postgresql-or-amazon-rds-for-postgresql/