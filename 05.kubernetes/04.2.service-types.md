# **Types of Kubernetes Services**

## **1. ClusterIP (Default Service Type)**

* Exposes the Service within the cluster only.
* Cannot be accessed from outside the cluster.
* Used for internal communication between Pods.

### **Example:** ClusterIP Service for an Nginx Pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
  - name: nginx-container
    image: nginx
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP
```

## **2. NodePort**

* Exposes the Service on each Node's IP at a static port (range 30000â€“32767).
* To access the application from browser, open the `nodePort` in the node's security group.
* Access the application using `http://<NodeIP>:<NodePort>`

### **Example:** NodePort Service for an Nginx Pod

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-nodeport
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
    nodePort: 30080
  type: NodePort
```

## **3. LoadBalancer**

* Provides an external IP using the cloud providerâ€™s load balancer.
* Used for exposing Services to the internet.

### **Example:** Classic Load Balancer (CLB)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-clb
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: LoadBalancer
```

* By default, EKS will create a Classic Load Balancer (CLB) when no annotations are specified.

### **Example:** Network Load Balancer (NLB)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "external"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "instance"
spec:
  type: LoadBalancer
  selector:
    app: nginx-server
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### **Documentation and References**

* [NLB Guide](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.7/guide/service/nlb/)
* [NLB Annotations](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.7/guide/service/annotations/)

#### **NLB Specific Notes**

* NLB does **not support managed security groups**.
* The controller modifies the **instance or pod ENI security group** to allow ingress.
* If using **instance mode**, it uses the **EC2 instanceâ€™s security group**.
* If using **IP mode**, it uses the **Podâ€™s ENI security group**.
* **Ensure that security groups are tagged** with:

  ```
  kubernetes.io/cluster/<cluster-name>: owned
  ```

#### **Target Type Modes**

##### **1. Instance Mode (default):**

* NLB targets are **EC2 Node IPs**.

* Traffic flows: **NLB â†’ Node IP\:Port â†’ Pod (via kube-proxy)**.

* You must open required ports in the **EC2 instanceâ€™s security group**.

* Use this annotation (optional since it's default):

  ```yaml
  service.beta.kubernetes.io/aws-load-balancer-target-type: instance
  ```

* **When to use:**

  * Simpler setup.
  * You don't need Pod-level network policies.
  * You're doing a basic demo or have low IP requirements.

##### **2. IP Mode:**

* NLB targets are **Pod IPs directly**.

* Traffic flows: **NLB â†’ Pod IP\:Port**.

* Requires **AWS VPC CNI plugin** with support for **secondary ENIs**.

* Pod ENIs can have **individual security groups**.

* Use this annotation:

  ```yaml
  service.beta.kubernetes.io/aws-load-balancer-target-type: ip
  ```

* **When to use:**

  * Fine-grained Pod-level network policies are required.
  * You want to bypass kube-proxy for performance (lower latency).
  * You're building multi-tenant or high-security workloads.

> **Note:** In IP mode, ensure your subnets have sufficient IPs. Pod-level ENIs consume more IP addresses, and IP exhaustion can block pod scheduling.

#### **Cost and Scaling Considerations**

* **No direct pricing difference** for target type, but:

  * **IP mode** uses more IP addresses per pod â†’ potential **subnet IP exhaustion**.
  * IP mode may require **larger subnet CIDRs** or IPAM configuration.
  * **Instance mode** scales by node count; **IP mode** scales by pod count.

#### **Accessing NLB**

* Open required ports in the security groups used by nodes (instance mode) or pod ENIs (ip mode).
* Use the **NLB DNS name** (from AWS Console or `kubectl get svc`) to access the service externally.
* Make sure your health checks work against pods/instances to keep NLB targets in "healthy" state.


## **4. ALB (Application Load Balancer)**

* Used with **Ingress**, not with Service of type `LoadBalancer`.
* Requires **AWS Load Balancer Controller**.

### **Prerequisites**

* Install AWS Load Balancer Controller:

  * Create IAM OIDC provider for the EKS cluster.
  * Attach IAM policy to the controllerâ€™s service account.
  * Install using Helm.

### **Example Ingress with ALB**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80
```

## **5. ExternalName**

* Maps a Service to an external DNS name.
* Used for integrating external services like databases.
* **No additional installation is required in EKS** to use ExternalName Services.
* Kubernetes' internal DNS system (CoreDNS) must be running and properly configured (enabled by default in EKS).
* Ensure that the external DNS name is resolvable from within the EKS cluster (i.e., DNS resolution works from the Pod's perspective).

### **Example:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: external-db
spec:
  type: ExternalName
  externalName: database.example.com
```

## **6. Headless Service**

* `clusterIP: None` disables virtual IP allocation.
* Useful for StatefulSets and DNS-based service discovery.

### **Example:**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: my-db
spec:
  serviceName: my-db-service
  replicas: 3
  selector:
    matchLabels:
      app: my-db
  template:
    metadata:
      labels:
        app: my-db
    spec:
      containers:
      - name: db-container
        image: postgres:latest
        ports:
        - containerPort: 5432
---
apiVersion: v1
kind: Service
metadata:
  name: my-db-service
spec:
  clusterIP: None
  selector:
    app: my-db
  ports:
  - protocol: TCP
    port: 5432
    targetPort: 5432
```

## **How to Resolve Pods Using a Headless Service**

```
db-0.my-db-service.default.svc.cluster.local
```

---

## **How Services Find and Connect to Pods**

1. **Selectors and Labels**: Services use `selector` to match Pods with specific labels.
2. **Endpoints**: Kubernetes tracks which Pods match the Service and updates endpoints.
3. **Kube-Proxy**: Handles forwarding requests to matched Pods.

---

## **Accessing Services**

* **Inside Cluster:** Use Service DNS name (e.g., `nginx-service`).
* **NodePort:** `http://<NodeIP>:<NodePort>` (ensure security group allows access).
* **LoadBalancer:** Use external DNS provided by cloud.
* **Ingress + ALB:** Route traffic via custom domain/path.

---

## **Conclusion**

* Kubernetes Services simplify internal and external communication.
* LoadBalancer supports CLB/NLB with different annotations.
* ALB requires Ingress and additional controller setup.
* Tags and security groups play a critical role in networking.
* Understanding modes (IP vs Instance) helps in troubleshooting NLB access.

By mastering Services, you unlock powerful routing, scalability, and integration in Kubernetes. ðŸš€
