# **Understanding ALB with Kubernetes Ingress**

## **Why ALB Cannot Be Used Directly with Service YAML**

* ALB (Application Load Balancer) is **designed to work at Layer 7 (HTTP/HTTPS)**.
* Kubernetes **Service of type `LoadBalancer`** supports only **Layer 4 (TCP)** load balancers, such as Classic Load Balancer (CLB) or Network Load Balancer (NLB).
* ALB integrates with Kubernetes via the **Ingress API**, which is designed to route HTTP/S traffic based on **hostnames and paths**.

> ðŸ“Œ Hence, you cannot create an ALB using only a `Service` manifest. It requires an **Ingress resource** to define the Layer 7 routing rules.

---

## **Why the ALB Ingress Controller Was Introduced**

* The native Kubernetes Ingress is a generic API that needs an **Ingress Controller** to function.
* AWS introduced the **AWS Load Balancer Controller** (formerly ALB Ingress Controller) to:

  * Automatically create and manage **Application Load Balancers (ALBs)**.
  * Translate Kubernetes Ingress objects into **ALB configurations**.
* This controller watches `Ingress` resources and provisions the necessary AWS resources dynamically.

---

## **Use Case: When to Use ALB with Ingress**

* You want **host-based or path-based routing**, e.g.,:

  * `app1.example.com` â†’ `app1-service`
  * `example.com/app2` â†’ `app2-service`
* You require **SSL termination** at the ALB.
* You need **native HTTP/HTTPS support** with URL rewrites, redirects, and WebSockets.
* You want to minimize the number of public load balancers (multiple services behind one ALB).

---

## **How to Install AWS Load Balancer Controller**

### **Install Prerequisites**

**Install Helm**
[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)

```powershell
choco install kubernetes-helm -y
```

**Install eksctl**
[https://eksctl.io/installation/](https://eksctl.io/installation/)

```powershell
choco install eksctl -y
```

**Enable EKS Add-ons:**
Make sure the following add-ons are enabled in your EKS cluster:

* Amazon VPC CNI plugin for Kubernetes
* kube-proxy
* CoreDNS

### **Set Environment Variables**

```bash
cluster_name=eks-dev-env
account_id=$(aws sts get-caller-identity --query "Account" --output text)
region=eu-west-2
vpc_id=$(aws eks describe-cluster --name ${cluster_name} --query "cluster.resourcesVpcConfig.vpcId" --output text)

echo ${cluster_name}
echo ${account_id}
echo ${region}
echo ${vpc_id}
```

### **Download and Create IAM Policy**

Check for the latest version of the policy:
[https://github.com/kubernetes-sigs/aws-load-balancer-controller/tags](https://github.com/kubernetes-sigs/aws-load-balancer-controller/tags)

```bash
# Download latest recommended IAM policy:
curl -o iam-policy.json https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/main/docs/install/iam_policy.json

# Create an IAM policy using the policy downloaded in the previous step.
aws iam create-policy \
  --policy-name AWSLoadBalancerControllerIAMPolicy \
  --policy-document file://iam_policy.json
```

> âš ï¸ If you are using an older version of the IAM policy file, it may be missing some required actions.
> For example, as of version `v2.12.0`, the `iam_policy.json` from this link:
> [https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.12.0/docs/install/iam\_policy.json](https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.12.0/docs/install/iam_policy.json)
> is missing the `ec2:DescribeRouteTables` permission.
>
> In such cases, if you encounter a `DescribeRouteTables` error, manually add this action to the policy:
>
> ```json
> {
>   "Effect": "Allow",
>   "Action": "ec2:DescribeRouteTables",
>   "Resource": "*"
> }
> ```

### **Create IRSA and Attach Policy via eksctl**

```bash
eksctl create iamserviceaccount \
  --cluster=${cluster_name} \
  --namespace=kube-system \
  --name=aws-load-balancer-controller \
  --attach-policy-arn=arn:aws:iam::${account_id}:policy/AWSLoadBalancerControllerIAMPolicy \
  --override-existing-serviceaccounts \
  --region ${region} \
  --approve
```

### **Verify IAM Service Account**

```bash
kubectl get sa -n kube-system

## verify the creation of service account, role with attached policy
kubectl describe sa aws-load-balancer-controller -n kube-system
```

Example output:

```text
Name:                aws-load-balancer-controller
Namespace:           kube-system
Labels:              app.kubernetes.io/managed-by=eksctl
Annotations:         eks.amazonaws.com/role-arn: arn:aws:iam::<account-id>:role/eksctl-eks-dev-env-addon-iamserviceaccount-ku-Role1
```

### **Add Helm Repo and Install Controller**

```bash
## Add the eks-charts Helm chart repository.
helm repo add eks https://aws.github.io/eks-charts

## Update your local repo to make sure that you have the most recent charts.
helm repo update eks

## Install the load balancer controller using helm.
helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
  -n kube-system \
  --set clusterName=${cluster_name} \
  --set serviceAccount.create=false \
  --set serviceAccount.name=aws-load-balancer-controller \
  --set vpcId=${vpc_id} \
  --set region=${region}
```

### **Verify Deployment**

```bash
kubectl get deployment -n kube-system aws-load-balancer-controller
```

Expected output:

```text
NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
aws-load-balancer-controller   2/2     2            2           84s
```

---
---
---

## **Sample Example Ingress Manifest for ALB**

```yaml
# 1. Pod Definition
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx-server
spec:
  containers:
  - name: nginx-container
    image: nginx:latest
    ports:
    - containerPort: 80
---
# 2. Service Definition
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  type: ClusterIP
  selector:
    app: nginx-server
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
---
# 3. Ingress Definition for ALB
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
spec:
  ingressClassName: alb
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80

```
---
---
---

## **Delete the ALB Ingress and Related Resources**

To clean up the ALB and all related AWS resources created via the AWS Load Balancer Controller:

### **Step 1: Delete the Ingress Resource**

```bash
kubectl delete ingress my-ingress
```

> This will trigger the AWS Load Balancer Controller to delete the associated ALB.

### **Step 2: Uninstall the Helm Chart**

```bash
helm uninstall aws-load-balancer-controller -n kube-system
```

### **Step 3: Delete the IAM Service Account**

```bash
eksctl delete iamserviceaccount \
  --cluster=${cluster_name} \
  --namespace=kube-system \
  --name=aws-load-balancer-controller \
  --region=${region}
```

> âœ… This command will remove the Kubernetes service account and delete the associated IAM role created by `eksctl`.

### **Step 4: Delete the IAM Policy (Optional)**

```bash
aws iam delete-policy \
  --policy-arn arn:aws:iam::${account_id}:policy/AWSLoadBalancerControllerIAMPolicy
```

> Note: Ensure no other IAM roles are using this policy before deletion.

---

## **Documentation and References**

* [AWS Load Balancer Controller GitHub](https://github.com/kubernetes-sigs/aws-load-balancer-controller)
* [Official AWS EKS Ingress Guide](https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html)
* [Ingress Resource in Kubernetes](https://kubernetes.io/docs/concepts/services-networking/ingress/)
* [Install AWS Load Balancer Controller with Helm](https://docs.aws.amazon.com/eks/latest/userguide/lbc-helm.html)
* [AWS Load Balancer Controller Release Page](https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases/)
* [ALB Ingress annotations](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.7/guide/ingress/annotations/)

---
---
---


# Types of Routing in Ingress

Kubernetes Ingress supports multiple routing mechanisms via annotations and rules. The two most commonly used types are:

* **Host-based routing**: Routes traffic based on the domain/subdomain.
* **Path-based routing**: Routes traffic based on the URL path under the domain.


In Kubernetes, an **Ingress** is an API object that manages external access to services in a cluster, typically HTTP. AWS provides the **Application Load Balancer (ALB)** as a Layer 7 load balancer that can intelligently route traffic based on rules. When using the **AWS Load Balancer Controller**, you can configure ALB with both **host-based** and **path-based** routing using annotations in your Ingress resources.

These routing mechanisms are especially useful when you want to:

* Host **multiple applications** on a single ALB.
* Route traffic to different backends **based on request URLs** or **hostnames**.

---

## Why We Need Host-Based and Path-Based Routing

### Without Routing:

If you create a `Service` of type `LoadBalancer`, each service gets its **own ELB**. This is:

* Costly (as you pay for each Load Balancer)
* Harder to manage (especially for many microservices)

### With ALB + Ingress:

* Use **one ALB** to handle multiple routes.
* Route requests to different services **based on domain (host)** or **URL path**.
* SSL termination and centralized traffic control.

---

## Host-Based Routing

**Use Case**: You have different applications and want each accessible under a different subdomain.

* `app1.example.com` â†’ forwards to `app1-service`
* `app2.example.com` â†’ forwards to `app2-service`

**Example Ingress YAML:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: host-routing-ingress
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:<region>:<account-id>:certificate/<cert-id>
    alb.ingress.kubernetes.io/ssl-redirect: '443'
spec:
  ingressClassName: alb
  rules:
  - host: app1.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
  - host: app2.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80
```

---

## Path-Based Routing

**Use Case**: You want to route requests based on path under the same domain.

* `example.com/app1/` â†’ forwards to `app1-service`
* `example.com/app2/` â†’ forwards to `app2-service`

**Example Ingress YAML:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-routing-ingress
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:<region>:<account-id>:certificate/<cert-id>
    alb.ingress.kubernetes.io/ssl-redirect: '443'
spec:
  ingressClassName: alb
  rules:
  - host: example.com
    http:
      paths:
      - path: /app1/*
        pathType: Prefix
        backend:
          service:
            name: app1-service
            port:
              number: 80
      - path: /app2/*
        pathType: Prefix
        backend:
          service:
            name: app2-service
            port:
              number: 80
```

---

## Summary

| Routing Type | Use Case                     | Example Host/Path                      |
| ------------ | ---------------------------- | -------------------------------------- |
| Host-based   | Different apps per subdomain | `app1.example.com`, `app2.example.com` |
| Path-based   | Different apps per path      | `example.com/app1/`, `example.com/app2/` |

---

## Real-World Examples: Google Services

### âœ… Host-based routing:

In host-based routing, the ALB routes traffic based on the domain (host) in the request.

| URL                                                          | Host                | Route Example            |
| ------------------------------------------------------------ | ------------------- | ------------------------ |
| [https://drive.google.com/](https://drive.google.com/)       | drive.google.com    | Route to Google Drive    |
| [https://mail.google.com/](https://mail.google.com/)         | mail.google.com     | Route to Gmail           |
| [https://calendar.google.com/](https://calendar.google.com/) | calendar.google.com | Route to Google Calendar |
| [https://docs.google.com/](https://docs.google.com/)         | docs.google.com     | Route to Google Docs     |

These are routed based on different subdomains, so this is **host-based routing**.

### âœ… Path-based routing:

In path-based routing, the ALB routes traffic based on the path after the domain.

| URL                                                                            | Host              | Path           | Route Example          |
| ------------------------------------------------------------------------------ | ----------------- | -------------- | ---------------------- |
| [https://docs.google.com/presentation/](https://docs.google.com/presentation/) | *docs.google.com* | /presentation/ | Route to Google Slides |
| [https://docs.google.com/spreadsheets/](https://docs.google.com/spreadsheets/) | docs.google.com   | /spreadsheets/ | Route to Google Sheets |

These are routed based on different paths under the same domain, so this is **path-based routing**.

---

## Conclusion

By using ALB Ingress with host-based or path-based routing, you simplify your infrastructure, reduce cost, and increase flexibility in managing multiple services. This approach is ideal for microservices, dev/test environments, and scalable production-grade architectures.

Make sure to use **valid ACM certificates**, **correct DNS records in Route 53**, and update ingress rules to match your application's structure.
