# Routing Traffic Based on Application Context Using ALB

## Scenario Overview
We have the following setup:
- `172.55.55.51:8080/java-application-1/`
- `172.55.55.52:8080/java-application-1/`
- `172.55.55.53:8080/java-application-2/`

### Why Not Use NLB?
A **Network Load Balancer (NLB)** operates at **Layer 4 (TCP/UDP)** and can only route traffic based on **IP and port**. It cannot route requests based on URL paths like `/java-application-1/` or `/java-application-2/`. Therefore, a single NLB cannot differentiate requests based on the application context.

While using multiple NLBs might work by splitting traffic based purely on ports, the correct way to route requests based on **URL paths** is by using an **Application Load Balancer (ALB)**.

---

## Solution Using ALB

### Steps to Achieve Path-Based Routing with ALB

#### 1. **Create Target Groups**
Target groups are used to route requests to the appropriate backend instances.

- Go to **EC2** -> **Target Groups** -> **Create Target Group**.

**Follow this process:**

1. **Choose a target type:**
   - Select **IP** to directly add instance IP addresses.

2. **Target group name:**
   - **java-application-1** for the first target group.
   - **java-application-2** for the second target group.

3. **Protocol:**
   - **HTTP**

4. **Port:**
   - **80** → This is the port on which alb is talking to the Target group

5. **Health checks:**

   **Health check protocol:**
   - **HTTP**

   **Health check path:**
   - `/java-application-1/` for the first target group.
   - `/java-application-2/` for the second target group.

   **Health check port:**
   - **Traffic port** → This means the health checks will be sent to the same port your targets are using, which is **8080**.

   **Healthy threshold:**
   - **2** → The number of consecutive successful health checks required for a target to be considered healthy.

   **Unhealthy threshold:**
   - **2** → The number of consecutive failed health checks required for a target to be considered unhealthy.

   **Timeout:**
   - **5 seconds** → How long ALB waits for a response from the target before marking it as a failure.

   **Interval:**
   - **15 seconds** → The interval between health check attempts.

6. **Register targets:**

   **Select available instances:**
   - Add the following IP addresses:
     - `172.55.55.51`
     - `172.55.55.52` (for **java-application-1** target group)
     - `172.55.55.53` (for **java-application-2** target group)

   **Ports for the selected instances:**
   - **8080** → This is the port your backend applications are running on. ALB will forward traffic to these instances on this port.

7. **Include as pending below:**
   - Click **Create the Target Group**.

---

#### 2. **Create an Application Load Balancer (ALB)**
- Navigate to the AWS Management Console.
- Go to **EC2** -> **Load Balancers** -> **Create Load Balancer**.
- Select **Application Load Balancer**.
- Set up the following:
  - **Name:** `my-application-alb`
  - **Scheme:** Internet-facing (or Internal, based on your use case)
  - **Listeners:**
    - HTTP, Port **80** (to allow traffic without needing to specify port 8080 in the URL)
  - **VPC:** Choose your existing VPC
  - **Availability Zones:** Select at least two subnets for high availability
  - **Default action:** Forward to one of the target groups (you can modify rules later)

Click **Create**.

> **Note:** ALB requires at least one listener during creation, and a default action must be defined, typically forwarding to a target group.

---

#### 3. **Configure Listener Rules**
- Go to **Load Balancers** -> Select your newly created ALB -> **Listeners** tab.
- Click **View/edit rules** for port 80.
- Add a new rule:
  - **If path is `/java-application-1/`** -> **Forward to `tg-java-application-1`**
  - **If path is `/java-application-2/`** -> **Forward to `tg-java-application-2`**
- Click **Save**.

---

#### 4. **Testing the Setup**
Once the ALB is set up and rules are configured:

- Access the ALB's DNS name (found in the Load Balancer description):
  - `http://<ALB-DNS-Name>/java-application-1/` should route to either `172.55.55.51` or `172.55.55.52`.
  - `http://<ALB-DNS-Name>/java-application-2/` should route to `172.55.55.53`.

---

### Summary
- **NLB** cannot route based on paths — only IP and port.
- **ALB** allows for path-based routing using listener rules.
- We configured two target groups:
  - One for `/java-application-1/` on port 8080.
  - Another for `/java-application-2/` on port 8080.
- The ALB routes traffic based on the URL path, ensuring the correct backend service handles each request.
- Health checks are set up using the correct paths (`/java-application-1/` and `/java-application-2/`).

This approach allows for flexible and dynamic routing of application traffic based on context-specific paths.

---
---
---

# Handling HTTP 302 Redirect in Spring Boot

## Issue Overview

When testing a Spring Boot application deployed behind an AWS Application Load Balancer (ALB), you might encounter an HTTP 302 response code. Let’s walk through the issue and how to fix it.

## Problem Statement

Consider the following Spring Boot application:


## Testing with `curl`
When running the application and testing the endpoint with `curl`:

```bash
curl -I http://18.132.41.147:8080/java-application-1
```

You receive a `302` redirect:

```
HTTP/1.1 302
Location: http://18.132.41.147:8080/java-application-1/
Transfer-Encoding: chunked
Date: Sun, 23 Feb 2025 10:22:51 GMT
```

Following the redirect:

```bash
curl -I http://18.132.41.147:8080/java-application-1/
```

You get a `200 OK`:

```
HTTP/1.1 200
Content-Type: text/plain;charset=UTF-8
Content-Length: 30
Date: Sun, 23 Feb 2025 10:22:54 GMT
```

## Why does this happen?
- In Spring Boot, a request to `/java-application-2` without a trailing slash triggers a **302 redirect** to `/java-application-2/`. This is default behavior, as Spring treats paths ending with `/` as directories.
- AWS ALB’s default health check uses the path you specify without adding a trailing slash, causing it to fail with 302 unless configured correctly.

## Solution
Update the ALB health check path to include the trailing slash:

1. Go to the AWS console.
2. Navigate to the target group attached to the ALB.
3. Edit the health check path:
   - **Old path:** `/java-application-2`
   - **New path:** `/java-application-2/`

Now, the health check will receive a `200 OK`, and the service will register as healthy.

## Conclusion
- The `302` happened because Spring Boot redirects non-slash-terminated URLs.
- Adjusting the ALB health check path fixed the issue.
- Always test both with and without the trailing slash to identify such subtle mismatches.

Would you like to expand this further with more examples or diagrams?


---
---
---
## Checklist for Developers

Here’s a checklist of what we need to make sure the health checks work properly with the ALB:

- Add a `/health` endpoint to the application.
- Ensure the `/health` endpoint returns a **200 OK** status when the application is healthy.
- Configure the **context path** correctly in `application.yaml` or `application.properties`.
- Test the **/health** endpoint both **locally** and in the **deployed environment**.
- Document the `/health` endpoint clearly in the application's **README** or **API documentation**.

Can you please make sure these points are covered? Let me know if there's anything blocking you or if the endpoint setup needs adjustments!