# Linux

## 1. Linux Servers Overview

Linux servers provide a stable and secure environment for running applications, hosting services, and managing system resources.

---

## 2. SSH Tools

SSH (Secure Shell) allows you to securely log in to a Linux server from your laptop.

### **Why SSH?**

It lets you control the server remotely as if you were physically present.

### **Common SSH Tools (Windows):**

* **PuTTY**
* **SuperPuTTY**
* **MobaXterm**

### **To Connect, You Need:**

* **Hostname or IP Address**
* **Username**
* **Password**

Without these, you cannot access the server.

---

## 3. FTP Tools (File Transfer Tools)

FTP tools are used to move files between your local machine and a Linux server.

### **Examples:**

* **WinSCP** – Windows only
* **FileZilla** – Works on Windows, Mac, and Linux

### **Usage:**

* Upload files to the server
* Download files from the server to your system

---

## 4. Linux Distributions

Different flavors of Linux exist, called distributions.

### **Popular Linux Distros:**

* Fedora
* CentOS
* RedHat
* Ubuntu
* SUSE Linux
* Gentoo
* Debian
* Slackware

---

## 5. Linux File / Directory Structure

Linux uses a hierarchical directory structure that starts at the **root directory** `/`. All files and folders exist under this main directory.

### **Important Directories:**

### **/** (Root Directory)

The top-most directory of the Linux filesystem.

---

### **/home**

Stores home directories for all users.

Example:

```
/home/gana
```

This is the home directory for the user **gana**.

---

### **/bin** (Binaries)

Contains basic binary executables used by normal users.
Examples:

* `ls`
* `mkdir`

---

### **/sbin** (System Binaries)

Contains system-level binaries accessible only by the root user.
Examples:

* `reboot`
* `shutdown`
* `chown`
* `chgsp`

**Difference between /bin and /sbin:**

* `/bin`: Commands usable by **normal users**.
* `/sbin`: Commands usable only by **root/system users**.

---

### **/etc**

Contains all configuration files of the Linux system.
Examples:

* `sudoers`
* `motd` (message of the day)
* `passwd`
* `groups`
* `shadow`

---

### **/proc**

Contains virtual files representing **process-related information**.

---

### **/opt**

Used to install third-party software.
By default, it is empty.

---

### **/dev** (Devices)

Contains information for all connected devices.
Examples:

* Hard disks
* Printers
* Scanners

---

### **/tmp**

Temporary files used by applications and the system.

---

### **/var**

Stores variable data like logs, cache, and spool files.
Example:

* `/var/log`

---

### **/lib**

Stores shared libraries required by binaries in /bin and /sbin.

---
---
---


# Linux Commands

This document contains clear explanations and examples of commonly used Linux commands.

## 1. ls

Lists files and directories.

* **ls** → Lists items in the current directory.
* **ls -l** → Long listing format (permissions, owner, size).
* **ls -lt** → Sorts by modification time (newest first).
* **ls -ltr** → Sorts by modification time (oldest first).

**Examples:**

```
ls
ls -l /var/log
ls -ltr /home
```

---

## 2. mkdir

Used to create directories.

* **mkdir folder** → Creates a directory.
* **mkdir -v folder** → Shows messages while creating.
* **mkdir -p a/b/c** → Creates parent directories automatically.
* **mkdir -m 755 mydir** → Creates folder with permissions.

**Examples:**

```
mkdir test
mkdir -v backups
mkdir -p project/src/modules
mkdir -m 700 secure_folder
```

---

## 3. cd

Used to move between directories.

* **cd path** → Go to the path.
* **cd ~** → Go to home directory.
* **cd -** → Go back to previous directory.

**Examples:**

```
cd /var/log
cd ~
cd -
```

---

## 4. rm

Used to delete files and folders.

* **rm file.txt** → Removes a file.
* **rm -r folder** → Removes folder recursively.
* **rm -rf folder** → Force delete (use carefully).

**Examples:**

```
rm old.txt
rm -r temp_folder
rm -rf /tmp/test
```

---

## 5. find

Used to search for files or directories.

### Common usage:

* **find /path -name filename** → Search by name.
* **find . -type f -name '*.log'** → Find log files.
* **find /var -size +100M** → Find large files.


**Find empty files in current directory:**

```
find . -type f -empty
```

**Find empty files in entire OS:**

```
find / -type f -empty
```

**Find empty directories:**

```
find . -type d -empty
```

**Find empty directories across OS:**

```
find / -type d -empty
```

**Find empty files in home directory:**

```
find ~ -type f -empty
```

**Search specific file:**

```
find / -name testfile.txt
```

**Find files with 777 permissions:**

```
find / -type f -perm 0777
```

**Find all executable files:**

```
find / -perm /a=x
```

---
---
---

## 6. Inode Numbers, Hard Links, and Soft Links in Linux

### a. What Is an Inode?

An **inode** is a data structure in Linux that stores metadata about a file. Every file has a unique inode number within a filesystem.

An inode stores:

* File type
* File size
* Ownership (user/group)
* Permissions
* Timestamps
* Pointers to data blocks
* **Inode number**

**Important:** The *filename is not stored in the inode*.
The filename exists in a directory and points to the inode.

---

### b. Why Inodes Matter

If two filenames point to the **same inode**, they are actually the **same file** (hard links).

If two files have **different inodes**, they are **different files**, even if the content is identical.

---

### c. How to View Inode Numbers

Use the following command:

```bash
ls -i filename
```

### Example 1 — Same inode (same file)

```bash
$ ls -i file1.txt file2.txt
123456 file1.txt
123456 file2.txt
```

These two filenames point to **the same inode**, meaning:

* ✔ Same file
* ✔ Changing one changes the other
* ✔ Deleting one does not delete the data until all links are removed

### Example 2 — Different inode (different files)

```bash
$ ls -i fileA.txt fileB.txt
123111 fileA.txt
123222 fileB.txt
```

This means:

* ❌ Not the same file
* ✔ Changing fileA does not affect fileB

---

### d. Demo: Creating Files and Checking Inodes

#### Step 1: Create two files

```bash
echo "hello" > a.txt
cp a.txt b.txt
```

#### Step 2: Check inode numbers

```bash
ls -i a.txt b.txt
```

Output example:

```
345621 a.txt
345622 b.txt
```

❌ Different inode numbers → different files

---

### e. Hard Links

A **hard link** is another name pointing to the **same inode**.

#### Characteristics

* Shares the **same inode** as the original file
* Both filenames refer to the **same physical data**
* Modifying one modifies the other
* Deleting one does not remove data while another hard link exists
* Cannot span across filesystems
* Cannot link directories

#### Example — Creating a Hard Link

```bash
echo "hello" > file1
ln file1 file2
ls -i file1 file2
```

Output:

```
123456 file1
123456 file2
```

✔ Same inode → same file

#### Editing a Hard Link

```bash
echo "World" >> file2
```

Now `file1` also contains the new content.

---

### f. Soft Links (Symbolic Links)

A **soft link** points to a **filename**, not an inode.
It behaves like a shortcut.

#### Characteristics

* Has its **own inode number**
* Points to the path of another file
* Can span filesystems
* Can link directories
* Becomes broken if the original file is deleted

#### Example — Creating a Soft Link

```bash
ln -s file1 file3
ls -i file1 file3
```

Output example:

```
123456 file1
789101 file3
```

❌ Different inode numbers → file3 is a pointer, not the same file

#### Soft Link Breakage Example

```bash
rm file1
cat file3
```

Output:

```
cat: file3: No such file or directory
```

➡ Soft link is now **broken**.

---

### g. Hard Links vs Soft Links — Comparison

| Feature                            | Hard Link        | Soft Link     |
| ---------------------------------- | ---------------- | ------------- |
| Inode number                       | Same as original | Different     |
| Points to                          | Inode            | Filename/path |
| Works across filesystems           | ❌ No             | ✔ Yes         |
| Can link directories               | ❌ No             | ✔ Yes         |
| Breaks if original file is removed | ✔ No             | ❌ Yes         |
| Acts as actual file                | ✔ Yes            | ❌ No          |

---

### h. Quick Demo Summary

```bash
# Create file
echo "hello" > file1

# Hard link
ln file1 file2

# Soft link
ln -s file1 file3
```

Check inode numbers:

```bash
ls -li file1 file2 file3
```

Example output:

```
123456 - file1
123456 - file2      # same inode → hard link
789012 - file3 -> file1   # soft link → pointer
```

---

### i. Summary

* **Inodes** help identify whether files are identical at the filesystem level.
* **Hard links** share the same inode and behave as one file.
* **Soft links** are shortcuts pointing to filenames.
* Inode numbers let you verify whether two files are truly the same.

This document can be copied directly into your `linux.md` file.



---
---
---

## 7. Umask, Permissions, chmod, chgrp, chown,

## a. umask (User Mask)

`umask` defines the **default permissions** for newly created files and directories.

### **Default umask values:**

| User Type   | umask | Default Directory Permission | Default File Permission |
| ----------- | ----- | ---------------------------- | ----------------------- |
| Root User   | 0022  | 0755                         | 0644                    |
| Normal User | 0002  | 0775                         | 0664                    |

### **Base permissions:**

* Directories → 0777
* Files → 0666

### **Formula:**

```
Final Permission = Base Permission - umask
```

---

## b. Permission Structure

Every file and directory has three sets of permissions:

* **Owner**
* **Group**
* **Others**

Permissions:

* r = read (4)
* w = write (2)
* x = execute (1)

---

## c. chmod (Change Mode)

```
chmod 755 file.txt
chmod u+r file.txt
chmod -R 700 dirx
```

---

## d. chgrp (Change Group)

```
chgrp wheel file
chgrp -R wheel dirx
```

Requires root or sudo privileges.

---

## e. chown (Change Ownership)

```
chown root file.txt
chown root:root file1.txt
chown ec2:ec2 testfile.txt
chown -R ec2:ec2 dir
```

---

## f. Combined Command Table

| Command  | Purpose                     | Example              |
| -------- | --------------------------- | -------------------- |
| chmod    | Change permissions          | chmod 755 file       |
| chmod -R | Recursive permission change | chmod -R 700 dir     |
| chgrp    | Change group                | chgrp wheel file     |
| chgrp -R | Recursive group change      | chgrp -R wheel dir   |
| chown    | Change owner                | chown root file      |
| chown    | Change owner+group          | chown ec2:ec2 file   |
| chown -R | Recursive ownership change  | chown -R ec2:ec2 dir |

---
---
---

## 8. `cat`, `head`, `tail`, and `Pipe Symbol`

### **cat** – View file content

* **`cat <file_name>`** → Displays the content of a file.
* **`cat -n <file_name>`** → Displays file content with line numbers.
* **Combine multiple files:**

    ```
    cat file1.txt file2.txt > combined.txt
    ```

    Creates a new file with both contents.
### **head** – Show beginning of a file

* **`head <file_name>`** → Shows first 10 lines.
* **`head -n 20 <file_name>`** → Shows first 20 lines.

### **tail** – Show end of a file

* **`tail <file_name>`** → Shows last 10 lines.
* **`tail -n 20 <file_name>`** → Shows last 20 lines.
* **`tail -f <file_name>`** → Live monitoring of file (commonly used for logs).

**Use Case:**

* Monitoring logs in real-time during deployments.

**Stopping tail -f:**

* **Ctrl + C** → Stop the process completely (terminate).
* **Ctrl + Z** → Suspend the process (pauses but not terminated).

---

### What is the pipe symbol (`|`)?

Pipe symbol sends the output of one command as input to another.

Example:

* **`cat file.txt | sort`** → Sorts the lines in alphabetical order.
* **`cat file.txt | sort -r`** → Sorts in reverse order.
* **`cat file.txt | sort | tr '[a-z]' '[A-Z]'`** → Sort alphabetically and convert all lowercase letters to uppercase.

* **Count number of unique lines:**

    ```
    cat file.txt | sort | uniq
    ```

* **Count number of occurrences:**

    ```
    cat file.txt | grep -i error | wc -l
    ```

    Counts lines containing word "error".

* **Filter, sort, and display only top 10:**

    ```
    cat access.log | grep "/api/" | sort | head -n 10
    ```

---

## 9. `vi` / `vim` Editor Commands

### Opening a file

* **`vi <file_name>`**
* **`vim <file_name>`**

### Common modes

* **Insert mode** → Press `i`
* **Command mode** → Press `Esc`

### Save & Exit

* `:w` → save
* `:q` → quit
* `:wq` → save and exit
* `:q!` → exit without saving

### Line Numbers

* `:se nu` → enable line numbers
* `:se nonu` → disable line numbers

### Search inside file

* `/<pattern>` → search forward
* `? <pattern>` → search backward
* `n` → next match
* `N` → previous match

### Useful vim shortcuts

* `dd` → delete line
* `yy` → copy (yank) line
* `p` → paste below
* `u` → undo
* `Ctrl + r` → redo
* `gg` → go to first line
* `G` → go to last line

---

## 10. `nano` Editor Commands

Open a file:

* **`nano <file_name>`**

### Common shortcuts

* **Ctrl + O** → Save the file (write out)
* **Ctrl + X** → Exit
* **Ctrl + K** → Cut line
* **Ctrl + U** → Paste line

---

## 11. `grep` Command

`grep` is used to search text inside files.

Examples:

* **`grep word file.txt`** → Search for exact word.
* **`grep -i word file.txt`** → Case‑insensitive search.
* **`grep -n word file.txt`** → Show line numbers.
* **`grep -r word /path`** → Recursive search in directories.

**Example content:**

```
apple
Banana
mango
APPLE
```

* `grep apple fruits.txt` → Finds only lowercase "apple"
* `grep Apple fruits.txt` → U can't find anything
* `grep -i apple fruits.txt` → Finds "apple" and "APPLE" (case‑insensitive)
* **Find IP addresses using regex:**

    ```
    grep -E "[0-9]{1,3}(\.[0-9]{1,3}){3}" access.log
    ```

---

## 12. `wc` Command (Word Count)

* **`wc -l <file>`** → Count number of lines
* **`wc -c <file>`** → Count number of bytes
* **`wc -w <file>`** → Count words
* **`wc <file>`** → Show all (lines, words, bytes)

---

## 13. `file` Command

Used to identify file type.

Examples:

* **`file file.txt`** → ASCII text
* **`file image.png`** → PNG image
* **`file script.sh`** → Bourne shell script
* **`file /bin/ls`** → ELF 64-bit binary

Use cases:

* Useful for debugging unknown files.
* Check whether a file is binary or text.
* Identify encodings or formats.

---
## 14. `df` Command — Disk Filesystem Usage

The `df` command displays disk space usage on mounted filesystems.

### **Examples:**

* **`df -h`** → Shows disk usage in human-readable format.
* **`df -h /var`** → Shows usage for `/var` mount.
* **`df -Th`** → Shows filesystem type (ext4, xfs, etc.).
* **`df -i`** → Shows inode usage.
* **`df -h | grep -E "xv|nvme"`** → Check AWS EC2 volumes.

### **Use Cases:****

* Check disk usage on servers.
* Troubleshoot *disk full* alerts.
* Verify EBS/NFS mount usage.

---

## 15. `du` Command — Disk Usage of Files/Directories

The `du` command displays how much space files or directories are consuming.

### **Examples:**

* **`du -sh *`** → Summary of all items in the current directory.
* **`du -sh /var/log`** → Check log directory size.
* **`du -ah / | sort -rh | head -10`** → Find top 10 largest directories/files.
* **`du -sm /* | sort -nr | head`** → Find largest directories by MB.
* **`du -sh --exclude=node_modules .`** → Check project size excluding folders.
* **`du -csh /opt/*`** → Get total size.

### **Use Cases:****

* Identify which directory is filling the disk.
* Analyze large logs or application folders.
* Debug disk-related alerts.

---

## 16. `ps` Command — Process Status

The `ps` command displays information about running processes.

### **Examples:**

* **`ps`** → Shows processes from current shell.
* **`ps -ef`** → Shows all processes in full format.
* **`ps aux`** → Alternative format.
* **`ps -ef | grep java`** → Search for Java processes.
* **`ps -ef --forest`** → Display processes in a tree view.
* **`ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu`** → Sort by CPU usage.
* **`ps -eo pid,cmd --sort=-%mem | head`** → Top memory consuming processes.

### **Killing Processes:**

* **`kill <PID>`** → Gracefully stop a process.
* **`kill -9 <PID>`** → Force kill a process.
* **`killall nginx`** → Kill all processes with name `nginx`.
* **`pkill -f app.py`** → Kill process by matching pattern.

### **Use Cases:****

* Debugging application hangs.
* Stopping rogue/unresponsive processes.
* Checking what processes are running on a server.

---

## 17. `zip` Command — Create ZIP Archives

Used to compress files and directories into `.zip` files.

### **Examples:**

* **`zip myfile.zip file.txt`** → Zip a single file.
* **`zip project.zip file1 file2`** → Zip multiple files.
* **`zip -r logs.zip /var/log`** → Zip a directory recursively.
* **`zip -r project.zip . -x "node_modules/*"`** → Exclude items.
* **`zip -r sources.zip src/ config/ scripts/`** → Zip multiple directories.
* **`zip -r backup.zip . -x "*.tmp"`** → Exclude temp files.

### **Use Cases:****

* Packaging artifacts for CI/CD.
* Compressing logs before upload.
* Sharing project files.

---

## 18. `unzip` Command — Extract ZIP Archives

Used to extract `.zip` files.

### **Examples:**

* **`unzip project.zip`** → Extract the ZIP file.
* **`unzip project.zip -d /tmp/output`** → Extract to a specific path.
* **`unzip -l project.zip`** → List ZIP contents.
* **`unzip -o project.zip`** → Overwrite without prompt.
* **`unzip logs.zip '*.log'`** → Extract only `.log` files.

### **Use Cases:****

* Deploying zipped application artifacts.
* Extracting backups.
* Viewing archive contents.

---

## 19. `tar` Command — Create and Extract TAR Archives

The `tar` command is widely used in Linux for backups, packaging, and deployments.

### **Creating TAR Files:**

* **`tar -cvf backup.tar /etc`** → Create `.tar` file.
* **`tar -czvf logs.tar.gz /var/log`** → Create compressed `.tar.gz`.
* **`tar -czvf project.tar.gz . --exclude=node_modules --exclude=.git`** → Exclude items.
* **`tar -czf app.tar.gz app.py requirements.txt templates/`** → Package application.

### **Extracting TAR Files:**

* **`tar -xvf backup.tar`** → Extract `.tar` file.
* **`tar -xzvf logs.tar.gz`** → Extract `.tar.gz`.
* **`tar -xzvf archive.tar.gz -C /var/www`** → Extract to directory.
* **`tar --strip-components=1 -xzvf archive.tar.gz`** → Extract without top folder.

### **Viewing TAR Contents:**

* **`tar -tf backup.tar`** → List contents.
* **`tar -tvf project.tar`** → Verbose view.

### **Use Cases:**

* Backups.
* Creating deployment packages.
* Compressing logs.
* Moving large directories efficiently.

---

## 20. `ssh` — Secure Shell (remote login)

`ssh` is the standard way to securely connect from one machine to another over the network.

### **Basic usage**

* `ssh -i key.pem ec2-user@ec2-11-22-33-44.compute.amazonaws.com` — use a private key file.

### **Common options**

* `-i <identity_file>` — specify private key to use.
* `-p <port>` — connect to a non-default port (default 22).
* `-o StrictHostKeyChecking=no` — disable host-key prompt (use cautiously in automation).



### **Ways to Connect to a Linux Server**

#### a. Username + Password (SSH)

```bash
ssh <username>@<server_ip>    ## it will prompt you to enter password
```

#### b. SSH Key Authentication (most secure)

```bash
ssh -i ~/.ssh/id_rsa <username>@<server_ip>
```


#### c. Bastion Host (Jump Server)

```bash
ssh -J <username>@<bastion_server_ip> <username>@<server_ip>
```

#### d. GUI SSH Clients (Windows)

* MobaXterm
* PuTTY

#### e. AWS SSM Session Manager (No SSH needed)

```bash
aws ssm start-session --target instance-id
```


---

---

## 21. `scp` — Secure Copy (copy files over SSH)

`scp` copies files securely between hosts using the SSH protocol.

### **Basic usage**

* `scp localfile <username>@<server_ip>:/remote/path/` — copy localfile to remote server.
* `scp <username>@<server_ip>:/remote/file ./` — copy file from remote to local.
* `scp -i key.pem -P 22 file <username>@<server_ip>:/path/` — specify key and port.
* `scp -r mydir <username>@<server_ip>:/backup/` — recursive copy for directories.

### **Examples**

* Copy artifact to server:

  ```bash
  scp -i ~/.ssh/devops.pem build/artifact.zip ubuntu@203.0.113.5:/var/www/releases/
  ```
* Copy remote logs to local workstation:

  ```bash
  scp ubuntu@203.0.113.5:/var/log/nginx/access.log ~/logs/
  ```
* Copy directory recursively:

  ```bash
  scp -r deploy/ ubuntu@203.0.113.5:/tmp/deploy-
  ```

* **Copying files using `scp` in automation** (use `-i` and avoid `StrictHostKeyChecking` prompts):

  ```bash
  scp -i ~/.ssh/ci_deploy.pem -o StrictHostKeyChecking=no build/app.tar.gz ec2-user@203.0.113.5:/tmp/
  ```

> Note: For large or repeated syncs use `rsync -e ssh` (more efficient and resumable).

---

## 22. Generating SSH Keys (passwordless auth)

Public-key authentication is the recommended way to authenticate to SSH servers.

### **Generate a key pair**

```bash
ssh-keygen -t rsa -b 4096 -C "john@example.com"
# or modern defaults
ssh-keygen -t ed25519 -C "john@example.com"
```

Follow prompts to save (default `~/.ssh/id_rsa` or `~/.ssh/id_ed25519`) and optionally set a passphrase.

### **Set correct permissions**

```bash
chmod 700 ~/.ssh
chmod 600 ~/.ssh/id_rsa
chmod 644 ~/.ssh/id_rsa.pub
```

### **Install public key on remote host**

* The easy way (if `ssh-copy-id` available):

  ```bash
  ssh-copy-id -i ~/.ssh/id_rsa.pub <username>@<server_ip>
  ```
* Manual method:

  ```bash
  # on local machine
  cat ~/.ssh/id_rsa.pub
  # copy the output, then on remote:
  mkdir -p ~/.ssh && chmod 700 ~/.ssh
  echo "<your-public-key>" >> ~/.ssh/authorized_keys
  chmod 600 ~/.ssh/authorized_keys
  ```

### **Using ssh-agent to cache passphrase**

```bash
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa
```

### **Examples**

* Connect without password (after installing public key):

  ```bash
  ssh ubuntu@203.0.113.5
  ```

---

## 23. `crontab` — Scheduled jobs (cron)

`cron` runs scheduled tasks (cron jobs) at specified times. Each user can have their own crontab.

### **Crontab file format**

A crontab line has six fields (five time fields + command):

```
┌──────── minute (0 - 59)
│ ┌────── hour (0 - 23)
│ │ ┌──── day of month (1 - 31)
│ │ │ ┌── month (1 - 12)
│ │ │ │ ┌ day of week (0 - 7) (Sun=0 or 7)
│ │ │ │ │
* * * * *  command to execute
```

## **Redirection in Crontab Commands**

When running scripts through cron, capturing logs is important.

### **Standard File Descriptors**

```
0 → Standard Input
1 → Standard Output
2 → Standard Error
```

### **Basic Redirection Operators**

* `>` → redirect standard output (overwrite)
* `>>` → append standard output
* `2>` → redirect standard error
* `2>&1` → redirect error (2) into output (1)

### **Redirection Examples**

##### Redirect only standard output:

```
/home/ganapathi/samplefile.sh > /home/ganapathi/output.log
```

##### Redirect both output & error to the same log:

```
/home/ganapathi/sample.sh > /home/ganapathi/output.log 2>&1
```

##### Append both output & error:

```
/home/ganapathi/sample.sh >> /home/ganapathi/output.log 2>&1
```

### **Crontab examples**

* Run backup script at 2:30am every day:

  ```cron
  30 2 * * * /home/john/scripts/backup.sh >> /home/john/backup.log 2>&1
  ```
* Run cleanup every Sunday at 3:00am:

  ```cron
  0 3 * * 0 /usr/local/bin/cleanup.sh
  ```
* Run every 15 minutes:

  ```cron
  */15 * * * * /usr/bin/check_health.sh >> /var/log/health.log 2>&1
  ```

### **Crontab commands (user-facing)**

* `crontab -e` — edit current user crontab.
* `crontab -l` — list current user crontab.
* `crontab -r` — remove current user crontab.
* `crontab -u username -l` — (as root) list another user’s crontab.
* `crontab -i -r` — interactive remove (asks for confirmation).

### **Files controlling crontab access**

* `/etc/cron.allow` — if this file exists only users listed here can use `crontab`.
* `/etc/cron.deny` — users listed here are denied (ignored if `cron.allow` exists).

### **Good practices**

* Redirect both stdout and stderr to logs: `>> /path/to/log 2>&1`.
* Use full absolute paths to commands and scripts.
* Test scripts manually before scheduling.
* Keep logs rotated (use `logrotate`).


### **Crontab Format — Quick Reference Table**

| Field           | Allowed values            | Example      | Meaning            |
| --------------- | ------------------------- | ------------ | ------------------ |
| Minute          | 0-59, `*`, `*/n`          | `0`          | exact minute       |
| Hour            | 0-23                      | `2`          | exact hour         |
| Day of month    | 1-31                      | `1`          | day of month       |
| Month           | 1-12 or names             | `1` or `Jan` | month              |
| Day of week     | 0-7 or names              | `0` or `Sun` | day of week        |
| Special strings | `@reboot`, `@daily`, etc. | `@weekly`    | schedule shorthand |

Examples of common schedules:

* `0 0 * * *` → daily at midnight
* `0 3 * * 0` → weekly on Sunday at 3:00am
* `*/5 * * * *` → every 5 minutes

---

## 24. `netstat` — Network statistics (legacy; `ss` is modern)

`netstat` shows active sockets, ports, routing tables, and network connections.

> Note: On some modern Linux distributions `netstat` is part of `net-tools` and may not be installed by default; `ss` is the recommended replacement.

### **Useful `netstat` options**

* `netstat -tuln` — show all listening TCP/UDP ports (numeric).
* `netstat -tulnp` — show listening ports with process id/program name (requires root).
* `netstat -ant` — show all TCP connections (numeric addresses).

### **Examples**

* Show listening ports with programs:

  ```bash
  sudo netstat -tulnp
  # tcp   0 0 0.0.0.0:22    0.0.0.0:* LISTEN  1234/sshd
  ```
* Find which process uses port 8080:

  ```bash
  sudo netstat -tulnp | grep :8080
  ```
* Show all established connections:

  ```bash
  netstat -ant | grep ESTABLISHED
  ```

### **`ss` - `Socket Statistics` equivalents (faster, more features)**

* `ss -tuln` — similar to `netstat -tuln`.
* `ss -tulpn` — show processes.
* `ss -s` — summary statistics.

### **Examples using `ss`**

```bash
sudo ss -tulpn | grep :80
ss -tuna | head
```

---

## 25. User Management in Linux

User and group administration is an essential part of Linux system administration. Below are the core commands and concepts with clean formatting and no duplicates.

---

### `useradd` — Create a New User

`useradd` is a low-level command used to create a new system user.

#### Examples

```bash
sudo useradd alice                     # Create a user
sudo useradd -m alice                  # Create user with home directory
sudo useradd -m -s /bin/bash alice     # Create user with specific shell
```

#### Files modified

* `/etc/passwd` — user information
* `/etc/shadow` — encrypted passwords
* `/etc/group` — group mapping

---

### `adduser` — Interactive User Creation

More user-friendly (Debian/Ubuntu). Prompts for password, full name, etc.

```bash
sudo adduser john
```

---

### Setting Password for a User

Used to set or change a user password.

```bash
sudo passwd alice
```

You will be asked to enter and confirm the new password.

---

### `chage` — Change User Password Expiry Settings

Modify password expiration, account expiry, and password aging.

#### View password settings:

```bash
sudo chage alice
```

#### Modify settings:

```bash
sudo chage -M 90 alice          # Password expires every 90 days
sudo chage -E 2025-12-31 alice  # Account expires on given date
```

---

### `groupadd` — Create a Group

```bash
sudo groupadd developers
```

#### View all groups

```bash
cat /etc/group
```

---

### `usermod` — Modify User Account

Used to change user properties such as group membership, home directory, and shell.

#### Change primary group

```bash
sudo usermod -g developers alice
```

#### Add user to supplementary groups

```bash
## sudo usermod -aG <group_name> <user_name>
sudo usermod -aG engineering alice
```

#### Change login shell

```bash
sudo usermod -s /bin/bash alice
```


#### Lock/Unlock account

```bash
sudo usermod -L alice    # Lock
sudo usermod -U alice    # Unlock
```

---

### Check User Group Membership

#### Using `groups`

```bash
groups alice
```

#### Using `id`

```bash
id alice
```

#### Using `/etc/group`

```bash
grep alice /etc/group
```

---

### List All Users in a Group

```bash
grep '^developers' /etc/group
```

OR

```bash
getent group developers
```

---

### Removing Users and Groups

#### Delete user (keep home directory)

```bash
sudo userdel john
```

#### Delete user and home directory

```bash
sudo userdel -r john
```

#### Delete group

```bash
sudo groupdel developers
```

---
---
---

## 26. `sed` — Stream Editor

`sed` is a powerful command-line text manipulation tool used to edit files or streams without opening them in an editor. It is essential for log processing, automation, scripting, and configuration management.

---

### **Basic Syntax**

```
sed 'pattern/action' file
```

---

## **Common `sed` Operations**

### **✔ Replace (Substitute)**

```
sed 's/old/new/' file                  # Replace first match per line
sed 's/old/new/g' file                # Replace all matches per line
sed -i 's/http/https/g' config.txt    # In‑place replacement
```

### **✔ Delete Lines**

```
sed '/ERROR/d' logs.txt               # Delete lines containing ERROR
sed '5d' file.txt                     # Delete line 5
sed '10,20d' file.txt                 # Delete lines 10 to 20
```

### **✔ Print Only Matching Lines**

```
sed -n '/INFO/p' app.log
sed -n '3,7p' file.txt                # Print lines 3 to 7
```

### **✔ Insert or Append Lines**

```
sed '/server {/i # Start of server block' nginx.conf     # Insert before match
sed '/server {/a # End of server block' nginx.conf       # Append after match
```

### **✔ Replace Only on Specific Line Number**

```
sed '3s/user/admin/' file.txt
```

### **✔ Replace Using Regex (Extended)**

```
sed -E 's/(id=)[0-9]+/\11234/' users.txt
```

### **✔ Real DevOps Example — Mask Secrets in Logs**

```
sed -E 's/(password=)[^&]+/\1********/g' app.log
```

### **✔ Edit File In‑Place With Backup**

```
sed -i.bak 's/staging/production/g' config.yaml
```

---

# 27. `awk` — Pattern Scanning and Processing

`awk` is a scripting language designed for text processing using patterns, conditions, and field (column) operations. It is extremely useful for log analysis, reporting, and metrics extraction.

---

### **Basic Syntax**

```
awk 'pattern { action }' file
```

---

## **Common `awk` Operations**

### **✔ Print Columns**

```
awk '{ print $1 }' sample.txt          # Print column 1
awk '{ print $1, $3 }' sample.txt      # Print column 1 and 3
awk '{ print $NF }' sample.txt         # Print last column
```

### **✔ Filter Rows Based on Conditions**

```
awk '$2 > 50' sample.txt                # Column 2 greater than 50
awk -F: '$3 > 1000 { print $1 }' /etc/passwd
```

### **✔ Use Custom Field Separator**

```
awk -F',' '{ print $2 }' users.csv
```

### **✔ Mathematical Operations**

```
awk '{ sum += $2 } END { print "Total:", sum }' data.txt
awk '{ sum += $2; count++ } END { print sum/count }' data.txt
```

### **✔ Print With Line Numbers**

```
awk '{ print NR, $0 }' file.txt
```

### **✔ Format Output Using printf**

```
awk '{ printf "%s -> %s\n", $1, $2 }' sample.txt
```

### **✔ Extract Specific Fields From Log Files**

```
awk '{ print $1 }' access.log           # Print IPs
```

### **✔ Count Occurrences of Each IP**

```
awk '{ count[$1]++ } END { for (ip in count) print ip, count[ip] }' access.log
```

### **✔ Real DevOps Example — High CPU Usage Filtering**

Given:

```
app1 30
app2 60
app3 85
```

Command:

```
awk '$2 > 50 { print "High CPU:", $1, $2"%" }' cpu.log
```

---

## **Summary — When to Use What?**

| Task                    | Tool  |
| ----------------------- | ----- |
| Replace text            | `sed` |
| Insert/Delete lines     | `sed` |
| Column-based operations | `awk` |
| Mathematical operations | `awk` |
| Log parsing             | `awk` |
| Quick line editing      | `sed` |

---
---
---

# 28. Additional Linux commands

## a) Difference: `sudo su` vs `sudo su -`

* `sudo su` : becomes root but **inherits** the current user's environment (PATH, current working directory). Useful when you want root but keep some of your environment.

* `sudo su -` (or `sudo -i`): becomes root and **initializes** a login shell (loads root's environment files like `/root/.profile`, `/root/.bash_profile`). You get root's home directory and login environment.

**Examples**

```bash
sudo su        # root shell, current directory preserved
sudo su -      # root login shell, moves to /root and loads root env
sudo -i        # similar to 'sudo su -'
```

---

## b) `date` command, EC2 timezone and IST

* `date` prints the current system date/time and timezone abbreviation.

```bash
date
# Example output: Sun Nov 23 15:04:05 UTC 2025
```

* EC2 instances default to **UTC** (unless you changed it). Cloud VM images typically use UTC so logs across regions stay consistent.

* To check timezone file:

```bash
timedatectl status
# or
ls -l /etc/localtime
```

* To set the instance to IST (India Standard Time, UTC+5:30):

```bash
sudo timedatectl set-timezone Asia/Kolkata
# verify
timedatectl status
```

* Notes: prefer keeping servers on UTC for production systems; convert times to local timezone only for human-facing displays or developer machines. If you set IST, logs will show IST timestamps — be mindful when correlating with other UTC systems.

---

## c) `more` and `less`

* `more file` — basic pager, forward-only (some older systems). Good for quick reading.
* `less file` — advanced pager: supports forward/backward navigation, search (`/pattern`), jumping to line numbers, and piping input. `less` is preferred.

**Examples**

```bash
less /var/log/syslog
# press 'q' to quit, '/' to search
```

---

## d) `ifconfig` (legacy) and modern alternative

* `ifconfig` shows network interfaces, IP addresses, and stats. On some systems `ifconfig` may be missing (net-tools not installed).

```bash
ifconfig -a
```

* Modern preferred command:

```bash
ip addr show
# or
ip a
```

---

## e) `hostname`

* `hostname` prints (or sets) the current hostname.

```bash
hostname
hostnamectl status
sudo hostnamectl set-hostname myserver
```

Use `hostnamectl` on systemd systems to permanently set the hostname.

---

## f) `top` command — server resource utility (monitor tool)

`top` shows live CPU, memory, swap, and process list. Useful fields and how to interpret them:

* **CPU%**: percent CPU usage per process.
* **%Cpu(s)** or CPU summary line: shows total CPU usage across all cores.
* **MiB Mem** (or similar): shows memory utilization (used, free, buffers/cache).
* **MiB Swap**: swap usage.

**Useful `top` interactions**

* `M` : sort by memory
* `P` : sort by CPU
* `k` : kill a PID (you will be prompted)
* `1` : toggle per-CPU display
* `q` : quit

**When to use `top`**

* If an application is reported slow / not working, check `top` to see CPU and RAM pressure. If a single process using 100% CPU, you may need to stop/restart it.

---

## g) Swap memory (when is swap used? how to create; suggested sizing)

**When is swap used?**

* Swap is used when RAM is fully utilized and the kernel needs extra virtual memory.
* If RAM utilization hits ~100%, the OS will use swap to keep processes running (but swapping is much slower than RAM).

* "Once RAM is utilized 100% then it is going to use swap memory. Swap memory we are going to create from hard disk."

**How to create swap (example)**

```bash
# create a 2G swapfile
sudo fallocate -l 2G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
# make persistent
echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
```

If `fallocate` isn't available, use:

```bash
sudo dd if=/dev/zero of=/swapfile bs=1M count=2048
```

**Suggested swap sizing**

* *If RAM is 1GB, swap should be 2GB.*
* Modern guidance varies; for small-memory VMs you can add 1–2× RAM as swap. For large-memory servers, smaller ratios (e.g., 0.5× or fixed sizes like 4GB) are common. Tailor to your workload.

---

## h) Disk/RAM/CPU troubleshooting case study (steps consolidated)

As a DevOps engineer, when the developer says "my app is not working":

1. **Check disk space** — if disk is full, the app cannot write logs and may fail.

```bash
df -h
```

2. **If disk space is OK, check RAM**:

```bash
free -h
```

* This shows `total`, `used`, `free`, `shared`, `buff/cache`, `available`.

3. **If RAM size is OK, check CPU**:

```bash
top
# or
ps aux --sort=-%cpu | head -n 10
```

4. **If CPU, RAM, and disk are OK, check application log files**:

* Each app should have one log file in a specified directory. Open logs and search for errors; share with dev team.

5. **If a process PID is taking 100% CPU**:

* Stop/restart the process to prevent impact on other processes and inform the job/application owner.

6. **If disk is low**:

* Clean log rotation, remove old files, expand disk (on EC2 resize EBS volume) and resize filesystem.

---

## i) Switching users: `su`, `su -`, `sudo` and `visudo`

**Switching users**

* `su username` — switch to `username` shell but keep current environment (home remains the same unless used with `-`). Password required for target user (unless run as root).
* `su - username` — login shell for `username` (switches to their home dir and loads login environment).
* `su` with no args switches to `root` (password required for root) unless using `sudo su`.

**Giving sudo privileges**

* Use `visudo` to edit `/etc/sudoers` safely. `visudo` locks the file and checks syntax before saving to avoid breaking sudo.

**Why `visudo` instead of editing `/etc/sudoers` directly?**

* If multiple users edit the file simultaneously or you make a syntax mistake, you can break `sudo`. `visudo` prevents concurrent edits and validates the file.

**Example entry**

```text
# give user 'ganapathi' sudo ALL=(ALL) ALL
ganapathi ALL=(ALL) ALL
```

---

## j) Who's logged in — commands to check users (out of 10 users, how many are logged in right now)

* `who` — lists logged-in users with terminals and login times.
* `w` — shows who is logged in and what they are doing (includes load average and uptime header).
* `users` — prints a space-separated list of logged-in user names (can be counted).
* `who -H` — prints header columns for clarity.
* `uptime` — shows how long system has been up and the load averages.

**Count logged-in users**

```bash
users | wc -w        # number of user sessions
# or unique usernames
users | tr ' ' '\n' | sort | uniq | wc -l
```

**Examples**

```bash
who
w
users
who -H
uptime
```

---

## k) What is load average and its 3 time intervals

* **Load average** shows the average number of runnable or uninterruptible processes (work queue length) over time.
* It is usually displayed as three numbers: **1 min**, **5 min**, **15 min** averages.

**Interpreting load average**

* Compare to number of CPU cores. If load = number of cores, system is fully utilized but not overloaded. If load >> cores, the system is overloaded and processes are waiting.

**Example**

* On a 4-core machine: load `0.50, 0.75, 0.60` → under-utilized. Load `6.0, 5.5, 4.0` → overloaded.

**Where to see it**

```bash
uptime
# or top (top shows the load averages in the header)
top -n 1 -b | head -n 1
```

---

## l) How to know how many CPUs are there in an EC2 instance

* `nproc` — prints number of processing units available to the OS.

```bash
nproc
```

* `lscpu` — detailed CPU info.

```bash
lscpu
```

* `cat /proc/cpuinfo | grep -c ^processor` — counts logical processors.

**EC2 specifics**

* EC2 instance types advertise vCPUs; `nproc`/`lscpu` shows how many the kernel sees.
* If you use hyperthreading, vCPUs include logical cores.

---

## m) How to know which user is currently logged in ?

* `whoami` — prints current effective username.
* `who` / `w` — show all logged-in users.
* `id` — shows current user identity and groups.

```bash
whoami
id
```

---

## o) `ping`

`ping` is used to test **network connectivity** between your server and another host. It sends ICMP echo requests to check if the target is reachable.

### **Examples**

```bash
ping google.com
```

Sends continuous packets until stopped (Ctrl + C).

```bash
ping -c 4 8.8.8.8
```

Sends only 4 packets.

### **Use cases**

* Check if a domain/server is reachable
* Measure latency (response time)
* Troubleshoot network issues

---

## p) `telnet`

`telnet` is used to test **port connectivity** to a server. It helps verify whether a specific port is open or blocked.

### **Examples**

```bash
telnet google.com 80
```

Checks if port 80 (HTTP) is accessible.

```bash
telnet 192.168.1.10 22
```

Tests SSH port access.

### **Use cases**

* Check if an application port is reachable
* Debug firewalls/security groups
* Test communication between services

> Note: Many systems no longer include telnet by default because it is insecure.

---

## q) `history`

`history` shows previously executed commands from the current user's session.

### **Examples**

```bash
history
```

Shows complete command list.

```bash
history | grep ssh
```

Filters history with a keyword.

```bash
!105
```

Runs the command at history line number 105.

### **Use cases**

* Recall previously used commands
* Audit what commands were executed
* Debug accidental or missing commands

---

## r) `cat /etc/os-release`

This command shows Linux OS information such as name, version, ID, and pretty name.

### **Example**

```bash
cat /etc/os-release
```

### **Sample Output**

```
NAME="Ubuntu"
VERSION="22.04.3 LTS (Jammy Jellyfish)"
ID=ubuntu
VERSION_ID="22.04"
PRETTY_NAME="Ubuntu 22.04.3 LTS"
```

### **Use cases**

* Identify OS details
* Check compatibility for installations
* Verify distribution version in scripts

---
