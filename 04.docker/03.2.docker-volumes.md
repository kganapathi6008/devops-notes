# Docker Volumes

## 1. Introduction to Docker Volumes
Docker volumes are the preferred way to persist data generated by and used by Docker containers. Unlike bind mounts, volumes are managed by Docker and offer a cleaner and safer way to handle data storage.

### Advantages of Docker Volumes:
- **Persistence**: Data stored in volumes survives container restarts and removals.
- **Portability**: Volumes can be easily backed up, migrated, and shared across multiple containers.
- **Isolation**: Docker handles volume management, ensuring security and data integrity.
- **Dynamic Storage**: Volumes use the host's storage (like EBS in AWS), dynamically allocating space as needed.

---

## 2. Creating and Using Volumes

### Create a Docker volume
```bash
docker volume create my_volume
```

### Verify the volume
```bash
docker volume ls
```

### Inspect the volume
```bash
docker volume inspect my_volume
```

---

## 3. Mounting Volumes to Containers

### Using `-v` option (bind mount)
You can mount a local directory to a container using the `-v` option:

```bash
# Syntax: docker run -v <host_path>:<container_path>
docker run -d -v /path/on/host:/usr/share/nginx/html -p 8080:80 nginx
```

Explanation:
- `/path/on/host`: Local directory on your host machine.
- `/usr/share/nginx/html`: Nginx's default document root.
- `-p 8080:80`: Maps port 8080 on the host to port 80 in the container.
- `-d`: Runs the container in detached mode.

Now, if you place an `index.html` file in `/path/on/host`, Nginx will serve it.

---

## 4. Nginx Home Page Example: Without and With Volumes

### Without Volumes (Changes are lost after container stops)

1. Run an Nginx container:
```bash
docker run -d --name nginx_no_volume -p 8080:80 nginx
```
2. Enter the container:
```bash
docker exec -it nginx_no_volume bash
```
3. Modify the Nginx homepage:
```bash
echo "<h1>Hello from Nginx inside container</h1>" > /usr/share/nginx/html/index.html
```
4. Access http://localhost:8080 â€” you'll see the custom page.
5. Stop and remove the container:
```bash
docker stop nginx_no_volume
```
6. Restart a new Nginx container â€” the changes are gone.

### With Volumes (Changes persist)

1. Create a volume:
```bash
docker volume create nginx_volume
```
2. Run Nginx using the volume:
```bash
docker run -d --name nginx_cont_with_volume -v nginx_volume:/usr/share/nginx/html -p 8080:80 nginx
```
3. Find the volume path:
```bash
docker volume inspect nginx_volume
```
4. Access the volume on the host and add a new homepage:
```bash
sudo find /var/lib/docker/volumes -name nginx_volume
cd /var/lib/docker/volumes/nginx_volume/_data
echo "<h1>Hello from Docker Volume</h1>" > index.html
```
5. Refresh http://localhost:8080 â€” you'll see the new homepage.

6. The changes persist even after stopping the container:
```bash
docker stop nginx_cont_with_volume
```

Restart the container, and the custom homepage remains:
```bash
docker start nginx_cont_with_volume
```

---

## 5. Synchronizing Changes Between Host and Container

If you make changes inside a container using a volume, they reflect on the host too.

1. Enter the running container:
```bash
docker exec -it nginx_cont_with_volume bash
```
2. Change the homepage:
```bash
echo "<h1>Updated from inside container</h1>" > /usr/share/nginx/html/index.html
```
3. Check the change on the host (from volume path):
```bash
cat /var/lib/docker/volumes/nginx_volume/_data/index.html
```
The updated content will be visible both in the container and on the host.

---

## 6. Volume Size and Storage

Docker volumes do **not** have a fixed size. They dynamically use space from the host's storage (like EBS on cloud platforms).

To check volume disk usage:
```bash
du -sh /var/lib/docker/volumes/nginx_volume/_data
```

If you're running Docker on cloud platforms like AWS, the total available space depends on the size of the host's EBS volume.

---

## 7. Removing Volumes

- Remove an unused volume:
```bash
docker volume rm my_volume
```
- Remove all unused volumes:
```bash
docker volume prune
```

**Important:** Removing a volume deletes all data stored in it. Be cautious!

---
---
---
# Running Jenkins with Docker

## 1. Pull the Jenkins Docker Image
```sh
docker pull jenkins/jenkins:lts
```
This command pulls the **Long-Term Support (LTS)** version of Jenkins.

---

## 2. Run Jenkins Container
```sh
docker run -d --name jenkins \
  -p 8080:8080 \
  -v jenkins_home:/var/jenkins_home \
  jenkins/jenkins:lts
```

### **Explanation:**
- `-d` â†’ Runs the container in detached mode.
- `--name jenkins` â†’ Names the container as "jenkins".
- `-p 8080:8080` â†’ Maps port **8080** (Jenkins UI) to the host.
- `-v jenkins_home:/var/jenkins_home` â†’ Creates a **persistent volume** for Jenkins data.

---

## 3. Get the Initial Admin Password
Run the following command to retrieve the **initial admin password** required to access Jenkins:
```sh
docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword
```
Copy this password and use it to unlock Jenkins on the web UI.

---

## 4. Access Jenkins Web UI
- Open your browser and go to:
  ðŸ‘‰ **http://localhost:8080**
- Paste the **initial admin password** when prompted.
- Complete the setup by installing recommended plugins.

---

## 5. Testing Jenkins Persistence
1. **Create a Sample Pipeline** in Jenkins after initial setup.
2. **Stop and Remove the Jenkins Container**
- Stop Jenkins:
  ```sh
  docker stop jenkins
  ```
- Remove Jenkins:
  ```sh
  docker rm jenkins
  ```
- Remove the Jenkins image (if needed):
  ```sh
  docker rmi jenkins/jenkins:lts
  ```
3. **Pull the Image and Run the Container Again**:
   ```sh
   docker pull jenkins/jenkins:lts
   docker run -d --name jenkins \
     -p 8080:8080 \
     -v jenkins_home:/var/jenkins_home \
     jenkins/jenkins:lts
   ```
4. **Login to Jenkins Web UI** at **http://localhost:8080**.
5. **Verify that your pipeline is still available**.

Since we used a **persistent volume (`jenkins_home`)**, Jenkins should retain all configurations, plugins, and pipelines even after recreating the container.

---
---
---

# Docker Volume and Storage Options

## 1. Running a Container Without Persistent Storage
```sh
docker run -d --name jenkins -p 8080:8080 jenkins/jenkins:lts
```

## 2. Using Bind Mounts
Bind mounts map a specific directory on the host machine to a container directory.
```sh
docker run -d --name jenkins \
  -p 8080:8080 \
  -v /host/path:/var/jenkins_home \
  jenkins/jenkins:lts
```

## 3. Using Named Volumes
Named volumes are managed by Docker and stored under `/var/lib/docker/volumes/`.
```sh
docker volume create jenkins_data

docker run -d --name jenkins \
  -p 8080:8080 \
  -v jenkins_data:/var/jenkins_home \
  jenkins/jenkins:lts
```

## 4. Using Anonymous Volumes
Anonymous volumes do not have a specific name and are automatically removed when the container is deleted.
```sh
docker run -d --name jenkins \
  -p 8080:8080 \
  -v /var/jenkins_home \
  jenkins/jenkins:lts
```

## 5. Using a Dockerfile to Define Volumes
You can specify a volume in a Dockerfile so that any container created from the image will have the specified mount point.

### Example Dockerfile:
```dockerfile
FROM jenkins/jenkins:lts
VOLUME /var/jenkins_home
```

To build and run:
```sh
docker build -t custom-jenkins .
docker run -d --name jenkins -p 8080:8080 custom-jenkins
```

## 6. Using Read-Only Volumes
You can mount a volume as read-only to prevent the container from modifying it.
```sh
docker run -d --name jenkins \
  -p 8080:8080 \
  -v jenkins_data:/var/jenkins_home:ro \
  jenkins/jenkins:lts
```

## 7. Using Docker Compose for Volume Management
Docker Compose simplifies volume management for multi-container applications.

### Example `docker-compose.yml`:
```yaml
version: '3.8'
services:
  jenkins:
    image: jenkins/jenkins:lts
    container_name: jenkins
    ports:
      - "8080:8080"
    volumes:
      - jenkins_data:/var/jenkins_home

volumes:
  jenkins_data:
```

### Running the Compose File:
```sh
docker-compose up -d
```

This approach ensures that the volume `jenkins_data` is managed by Docker Compose and persists across container restarts.

## Summary of Volume Types
| Volume Type        | Description |
|--------------------|-------------|
| Bind Mount        | Maps a specific host directory to a container path. |
| Named Volume      | Managed by Docker, stored under `/var/lib/docker/volumes/`. |
| Anonymous Volume  | Created automatically, removed when the container stops. |
| Defined in Dockerfile | Persistent across containers using `VOLUME`. |
| Read-Only Volume  | Mounted with `:ro` to restrict write access. |
| Docker Compose Volume | Defined in `docker-compose.yml`, managed automatically. |

Each method has its own use case depending on the level of control and persistence required.

